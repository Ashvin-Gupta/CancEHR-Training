{% extends "base.html" %}

{% block title %}Benchmarks - Nightingale{% endblock %}

{% block content %}
<section class="hero">
    <h1>Benchmark Results</h1>
    <p class="hero-subtitle">
        Rollout Performance Analysis
    </p>
</section>

<section class="benchmarks">
    {% if experiments %}
    <div class="controls-panel">
        <div class="control-group">
            <h3>Select Experiment</h3>
            <select id="experiment-select" class="control-select">
                <option value="">Choose an experiment...</option>
                {% for experiment in experiments %}
                <option value="{{ experiment.name }}">{{ experiment.name }} ({{ experiment.model_type }})</option>
                {% endfor %}
            </select>
        </div>

        <div class="control-group">
            <h3>Select Benchmark</h3>
            <select id="benchmark-select" class="control-select" disabled>
                <option value="">Choose a benchmark...</option>
            </select>
        </div>

        <div class="control-group">
            <button id="load-benchmark" class="btn btn-primary" disabled>Load Benchmark Data</button>
        </div>
    </div>

    <!-- Loading indicator -->
    <div id="loading" class="chart-container" style="display: none;">
        <div style="text-align: center; padding: 2rem;">
            <p>Loading benchmark data...</p>
        </div>
    </div>

    <!-- Error display -->
    <div id="error-display" class="chart-container" style="display: none; background: #ffeaea; border-color: #ff6b6b;">
        <div style="text-align: center; padding: 2rem; color: #d63031;">
            <h3>Error Loading Data</h3>
            <p id="error-message"></p>
        </div>
    </div>

    <!-- Benchmark info -->
    <div id="benchmark-info" class="models-list" style="display: none;">
        <h3>Benchmark Configuration</h3>
        <div id="config-details"></div>
    </div>

    <!-- Charts container -->
    <div id="charts-container" style="display: none; margin-top: 32px;">
        <!-- Accuracy by Real End Token -->
        <div class="chart-container">
            <h3>Accuracy by Real End Token</h3>
            <canvas id="accuracy-chart" width="800" height="400"></canvas>
        </div>

        <!-- Population Distribution -->
        <div class="chart-container">
            <h3>Population Distribution: Ground Truth vs Predicted</h3>
            <canvas id="population-chart" width="800" height="400"></canvas>
        </div>

        <!-- Confusion Matrix -->
        <div class="chart-container">
            <h3>Confusion Matrix</h3>
            <div class="confusion-matrix-info">
                <p><strong>Diagonal (green):</strong> Correct predictions | <strong>Off-diagonal (red):</strong> Misclassifications | <strong>Accuracy:</strong> <span id="overall-accuracy">-</span></p>
            </div>
            <div class="table-container" style="overflow-x: auto; max-width: 100%;">
                <table id="confusion-table" class="confusion-matrix-table">
                    <thead>
                        <tr>
                            <th class="matrix-corner">Actual \ Predicted</th>
                        </tr>
                    </thead>
                    <tbody>
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    {% else %}
    <div class="no-experiments">
        <h3>No Benchmark Results Found</h3>
        <p>No experiments with benchmark results found in the results directory.</p>
    </div>
    {% endif %}
</section>
{% endblock %}

{% block extra_scripts %}
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
// Store experiments data for benchmark selection
const experimentsData = {{ experiments | tojson }};

// Chart instances
let accuracyChart = null;
let populationChart = null;

// DOM elements
const experimentSelect = document.getElementById('experiment-select');
const benchmarkSelect = document.getElementById('benchmark-select');
const loadButton = document.getElementById('load-benchmark');
const loading = document.getElementById('loading');
const errorDisplay = document.getElementById('error-display');
const errorMessage = document.getElementById('error-message');
const benchmarkInfo = document.getElementById('benchmark-info');
const chartsContainer = document.getElementById('charts-container');
const configDetails = document.getElementById('config-details');

// Event listeners
experimentSelect.addEventListener('change', onExperimentChange);
benchmarkSelect.addEventListener('change', onBenchmarkChange);
loadButton.addEventListener('click', loadBenchmarkData);

function onExperimentChange() {
    const selectedExperiment = experimentSelect.value;
    
    // Clear benchmark selection
    benchmarkSelect.innerHTML = '<option value="">Choose a benchmark...</option>';
    benchmarkSelect.disabled = true;
    loadButton.disabled = true;
    
    if (selectedExperiment) {
        const experiment = experimentsData.find(exp => exp.name === selectedExperiment);
        if (experiment && experiment.benchmarks) {
            // Populate benchmark options
            experiment.benchmarks.forEach(benchmark => {
                const option = document.createElement('option');
                option.value = benchmark.name;
                option.textContent = benchmark.name;
                benchmarkSelect.appendChild(option);
            });
            benchmarkSelect.disabled = false;
        }
    }
    
    hideCharts();
}

function onBenchmarkChange() {
    const selectedBenchmark = benchmarkSelect.value;
    loadButton.disabled = !selectedBenchmark;
    hideCharts();
}

function hideCharts() {
    benchmarkInfo.style.display = 'none';
    chartsContainer.style.display = 'none';
    errorDisplay.style.display = 'none';
    if (accuracyChart) {
        accuracyChart.destroy();
        accuracyChart = null;
    }
    if (populationChart) {
        populationChart.destroy();
        populationChart = null;
    }
    // Clear confusion matrix table
    const confusionTable = document.getElementById('confusion-table');
    if (confusionTable) {
        confusionTable.querySelector('thead tr').innerHTML = '<th>Actual \\ Predicted</th>';
        confusionTable.querySelector('tbody').innerHTML = '';
    }
}

async function loadBenchmarkData() {
    const experiment = experimentSelect.value;
    const benchmark = benchmarkSelect.value;
    
    if (!experiment || !benchmark) return;
    
    // Show loading
    hideCharts();
    loading.style.display = 'block';
    
    try {
        const response = await fetch(`/api/benchmark-data?experiment=${experiment}&benchmark=${benchmark}`);
        const data = await response.json();
        
        loading.style.display = 'none';
        
        if (data.error) {
            showError(data.error);
            return;
        }
        
        // Display benchmark info
        displayBenchmarkInfo(data.config, data.summary);
        
        // Create charts
        createAccuracyChart(data.accuracy_by_token);
        createPopulationChart(data.population_distribution);
        createConfusionMatrixTable(data.confusion_matrix);
        
        chartsContainer.style.display = 'block';
        
    } catch (error) {
        loading.style.display = 'none';
        showError(`Failed to load benchmark data: ${error.message}`);
    }
}

function showError(message) {
    errorMessage.textContent = message;
    errorDisplay.style.display = 'block';
}

function displayBenchmarkInfo(config, summary) {
    const html = `
        <div class="stats-grid">
            <div class="stat-item">
                <span class="stat-label">Total Subjects:</span>
                <span class="stat-value">${summary.total_subjects}</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Temperature:</span>
                <span class="stat-value">${config.parameters.temperature}</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Rollouts per Subject:</span>
                <span class="stat-value">${config.parameters.num_rollouts}</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Max Steps:</span>
                <span class="stat-value">${config.parameters.max_steps}</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Dataset:</span>
                <span class="stat-value">${config.dataset.name}</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Timestamp:</span>
                <span class="stat-value">${new Date(config.timestamp).toLocaleString()}</span>
            </div>

        </div>
        <div class="token-info">
            <div class="token-section">
                <h4>Start Token:</h4>
                <div class="token-display" title="${config.dataset.start_token || 'N/A'}">${truncateToken(config.dataset.start_token || 'N/A')}</div>
            </div>
            <div class="token-section">
                <h4>End Tokens:</h4>
                <div class="token-list">
                    ${config.dataset.end_tokens ? 
                        config.dataset.end_tokens.map(token => `<span class="token-item" title="${token}">${truncateToken(token)}</span>`).join('') : 
                        '<span class="token-item">N/A</span>'
                    }
                </div>
            </div>
        </div>
    `;
    configDetails.innerHTML = html;
    benchmarkInfo.style.display = 'block';
}

function createAccuracyChart(accuracyData) {
    const ctx = document.getElementById('accuracy-chart').getContext('2d');
    
    const labels = Object.keys(accuracyData);
    const accuracies = labels.map(label => accuracyData[label].accuracy * 100);
    const counts = labels.map(label => accuracyData[label].total);
    
    // Color coding: red for death, blue for others
    const backgroundColors = labels.map(label => 
        label.includes('DEATH') ? 'rgba(239, 68, 68, 0.7)' : 'rgba(59, 130, 246, 0.7)'
    );
    const borderColors = labels.map(label => 
        label.includes('DEATH') ? 'rgb(239, 68, 68)' : 'rgb(59, 130, 246)'
    );
    
    accuracyChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Accuracy (%)',
                data: accuracies,
                backgroundColor: backgroundColors,
                borderColor: borderColors,
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            scales: {
                y: {
                    beginAtZero: true,
                    max: 100,
                    title: {
                        display: true,
                        text: 'Accuracy (%)'
                    }
                },
                x: {
                    title: {
                        display: true,
                        text: 'Real End Token'
                    }
                }
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        afterLabel: function(context) {
                            const index = context.dataIndex;
                            return `Sample size: ${counts[index]}`;
                        }
                    }
                }
            }
        }
    });
}

function createPopulationChart(populationData) {
    const ctx = document.getElementById('population-chart').getContext('2d');
    
    const tokens = populationData.tokens;
    const groundTruth = populationData.ground_truth;
    const predicted = populationData.predicted;
    
    // Prepare data for the chart
    const groundTruthPercentages = tokens.map(token => groundTruth[token].percentage);
    const predictedPercentages = tokens.map(token => predicted[token].percentage);
    const groundTruthCounts = tokens.map(token => groundTruth[token].count);
    const predictedCounts = tokens.map(token => predicted[token].count);
    
    populationChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: tokens.map(token => {
                // Abbreviate long token names for display
                return token.length > 20 ? token.substring(0, 17) + '...' : token;
            }),
            datasets: [
                {
                    label: 'Ground Truth',
                    data: groundTruthPercentages,
                    backgroundColor: 'rgba(59, 130, 246, 0.7)',
                    borderColor: 'rgba(59, 130, 246, 1)',
                    borderWidth: 1
                },
                {
                    label: 'Model Predicted',
                    data: predictedPercentages,
                    backgroundColor: 'rgba(239, 68, 68, 0.7)',
                    borderColor: 'rgba(239, 68, 68, 1)',
                    borderWidth: 1
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    title: {
                        display: true,
                        text: 'End Token Types',
                        font: { weight: 'bold' }
                    }
                },
                y: {
                    title: {
                        display: true,
                        text: 'Percentage of Population (%)',
                        font: { weight: 'bold' }
                    },
                    beginAtZero: true,
                    max: 110,
                    ticks: {
                        stepSize: 10,
                        callback: function(value) {
                            return value + '%';
                        }
                    }
                }
            },
            plugins: {
                title: {
                    display: true,
                    text: `Population Distribution (n=${populationData.total_subjects} subjects)`,
                    font: { size: 16, weight: 'bold' }
                },
                legend: {
                    display: true,
                    position: 'top'
                },
                tooltip: {
                    callbacks: {
                        title: function(context) {
                            // Get full token name from the index
                            const fullToken = tokens[context[0].dataIndex];
                            return fullToken;
                        },
                        label: function(context) {
                            const tokenIdx = context.dataIndex;
                            const isGroundTruth = context.datasetIndex === 0;
                            const percentage = context.parsed.y;
                            const count = isGroundTruth ? groundTruthCounts[tokenIdx] : predictedCounts[tokenIdx];
                            const label = isGroundTruth ? 'Ground Truth' : 'Model Predicted';
                            
                            return [
                                `${label}: ${percentage}%`,
                                `Count: ${count} subjects`
                            ];
                        }
                    },
                    displayColors: true
                }
            }
        }
    });
}

function createConfusionMatrixTable(confusionData) {
    const table = document.getElementById('confusion-table');
    const thead = table.querySelector('thead tr');
    const tbody = table.querySelector('tbody');
    
    const labels = confusionData.labels;
    const matrix = confusionData.matrix;
    
    // Clear existing content
    thead.innerHTML = '<th class="matrix-corner">Actual \\ Predicted</th>';
    tbody.innerHTML = '';
    
    // Calculate totals and accuracy
    const rowTotals = matrix.map(row => row.reduce((sum, val) => sum + val, 0));
    const colTotals = labels.map((_, colIdx) => 
        matrix.reduce((sum, row) => sum + row[colIdx], 0)
    );
    const grandTotal = rowTotals.reduce((sum, val) => sum + val, 0);
    const correctPredictions = matrix.reduce((sum, row, idx) => sum + row[idx], 0);
    const overallAccuracy = grandTotal > 0 ? ((correctPredictions / grandTotal) * 100).toFixed(1) : '0.0';
    
    // Update overall accuracy display
    document.getElementById('overall-accuracy').textContent = `${overallAccuracy}%`;
    
    // Add column headers with abbreviated labels
    labels.forEach((label, idx) => {
        const th = document.createElement('th');
        const abbreviatedLabel = abbreviateLabel(label);
        th.innerHTML = `<div class="header-content">${abbreviatedLabel}</div>`;
        th.className = 'matrix-header';
        th.title = label; // Full label on hover
        thead.appendChild(th);
    });
    
    // Add total column
    const totalTh = document.createElement('th');
    totalTh.innerHTML = '<div class="header-content">Total</div>';
    totalTh.className = 'matrix-header total-header';
    thead.appendChild(totalTh);
    
    // Add data rows
    matrix.forEach((row, rowIdx) => {
        const tr = document.createElement('tr');
        tr.className = 'matrix-row';
        
        // Row header (actual label)
        const th = document.createElement('th');
        th.textContent = abbreviateLabel(labels[rowIdx]);
        th.className = 'matrix-row-header';
        th.title = labels[rowIdx]; // Full label on hover
        tr.appendChild(th);
        
        // Calculate row accuracy for highlighting
        const rowAccuracy = rowTotals[rowIdx] > 0 ? (row[rowIdx] / rowTotals[rowIdx]) : 0;
        
        // Data cells
        row.forEach((count, colIdx) => {
            const td = document.createElement('td');
            const percentage = rowTotals[rowIdx] > 0 ? ((count / rowTotals[rowIdx]) * 100).toFixed(0) : '0';
            
            // Show count and percentage for non-zero values
            if (count > 0) {
                td.innerHTML = `<div class="cell-count">${count}</div><div class="cell-percentage">(${percentage}%)</div>`;
            } else {
                td.innerHTML = '<div class="cell-count">0</div>';
            }
            
            td.className = 'matrix-cell';
            
            // Color coding based on cell type and accuracy
            if (rowIdx === colIdx) {
                // Diagonal cells (correct predictions)
                if (count > 0) {
                    td.classList.add('correct-prediction');
                } else {
                    // Zero diagonal cells - no special background
                    td.style.color = '#9ca3af';
                }
            } else if (count > 0) {
                // Off-diagonal cells (errors)
                td.classList.add('incorrect-prediction');
            } else {
                // Zero off-diagonal cells - no special background
                td.style.color = '#d1d5db';
            }
            
            // Add hover effect with detailed info
            td.title = `Actual: ${labels[rowIdx]}\nPredicted: ${labels[colIdx]}\nCount: ${count}\nRow %: ${percentage}%`;
            
            tr.appendChild(td);
        });
        
        // Row total with accuracy indicator
        const totalTd = document.createElement('td');
        const accuracy = rowTotals[rowIdx] > 0 ? ((row[rowIdx] / rowTotals[rowIdx]) * 100).toFixed(0) : '0';
        totalTd.innerHTML = `<div class="cell-count">${rowTotals[rowIdx]}</div><div class="cell-accuracy">${accuracy}% acc</div>`;
        totalTd.className = 'matrix-cell total-cell';
        tr.appendChild(totalTd);
        
        tbody.appendChild(tr);
    });
    
    // Add column totals row
    const totalRow = document.createElement('tr');
    totalRow.className = 'matrix-total-row';
    
    const totalRowHeader = document.createElement('th');
    totalRowHeader.textContent = 'Total';
    totalRowHeader.className = 'matrix-row-header total-header';
    totalRow.appendChild(totalRowHeader);
    
    colTotals.forEach((total, colIdx) => {
        const td = document.createElement('td');
        const precision = total > 0 ? ((matrix[colIdx][colIdx] / total) * 100).toFixed(0) : '0';
        td.innerHTML = `<div class="cell-count">${total}</div><div class="cell-accuracy">${precision}% prec</div>`;
        td.className = 'matrix-cell total-cell';
        totalRow.appendChild(td);
    });
    
    // Grand total cell
    const grandTotalTd = document.createElement('td');
    grandTotalTd.innerHTML = `<div class="cell-count">${grandTotal}</div><div class="cell-accuracy">${overallAccuracy}% acc</div>`;
    grandTotalTd.className = 'matrix-cell grand-total-cell';
    totalRow.appendChild(grandTotalTd);
    
    tbody.appendChild(totalRow);
}

// Helper function to truncate long labels while keeping original format
function abbreviateLabel(label) {
    // Keep labels under 20 characters as-is
    if (label.length <= 20) return label;
    
    // For longer labels, truncate intelligently
    if (label.includes('//')) {
        // Split on // and truncate parts if needed
        const parts = label.split('//');
        const truncatedParts = parts.map(part => {
            if (part.length > 12) {
                return part.substring(0, 9) + '...';
            }
            return part;
        });
        const result = truncatedParts.join('//');
        
        // If still too long, truncate the whole thing
        if (result.length > 25) {
            return result.substring(0, 22) + '...';
        }
        return result;
    }
    
    // Generic truncation for labels without //
    return label.substring(0, 17) + '...';
}

// Helper function to truncate tokens with middle ellipsis for better readability
function truncateToken(token) {
    if (!token || token === 'N/A' || token.length <= 30) return token;
    
    // Use start...end format for long tokens
    const start = token.substring(0, 15);
    const end = token.substring(token.length - 10);
    return `${start}...${end}`;
}
</script>
{% endblock %}
