{% extends "base.html" %}

{% block title %}Simulation Analysis - Nightingale{% endblock %}

{% block extra_head %}
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
{% endblock %}

{% block content %}
<section class="hero">
    <h1>Simulation Analysis</h1>
    <p class="hero-subtitle">
        Analyze Stop Reasons and Token Distributions
    </p>
</section>

<section class="simulations">
    {% if simulation_experiments %}
    <div class="controls-panel">
        <div class="control-group">
            <h3>Select Experiment:</h3>
            <select id="experiment-select" class="control-select">
                <option value="">-- Select an experiment --</option>
                {% for experiment in simulation_experiments %}
                <option value="{{ experiment.name }}">
                    {{ experiment.name }} ({{ experiment.model_type|upper }})
                </option>
                {% endfor %}
            </select>
        </div>
        
        <div class="control-group">
            <h3>Select Simulation:</h3>
            <select id="simulation-select" class="control-select" disabled>
                <option value="">-- Select experiment first --</option>
            </select>
        </div>
        
        <div class="control-group">
            <h3>Smoothing:</h3>
            <div class="smoothing-controls">
                <label for="smoothing-slider" class="smoothing-label">
                    <span>None</span>
                    <input type="range" id="smoothing-slider" min="1" max="21" value="1" step="2" class="smoothing-slider">
                    <span>High</span>
                </label>
                <div class="smoothing-value">Window Size: <span id="smoothing-display">1</span></div>
            </div>
        </div>
        
        <div class="simulation-info" id="simulation-info" style="display: none;">
            <h4>Simulation Statistics:</h4>
            <div class="stats-grid">
                <div class="stat-item">
                    <span class="stat-label">Total Simulations:</span>
                    <span class="stat-value" id="total-simulations">-</span>
                </div>
            </div>
        </div>
    </div>
    
    <div class="charts-container" id="charts-container" style="display: none;">
        <div class="chart-section">
            <h3>Stop Reason Distribution</h3>
            <div class="chart-container">
                <canvas id="stopReasonChart"></canvas>
            </div>
        </div>
        
        <div class="chart-section">
            <h3>Stop Token Distribution (by Token Type)</h3>
            <div class="chart-container">
                <canvas id="stopValueChart"></canvas>
            </div>
        </div>
    </div>
    
    {% else %}
    <div class="no-data">
        <h3>No Simulation Data Found</h3>
        <p>No experiments with simulation results found.</p>
    </div>
    {% endif %}
</section>
{% endblock %}

{% block extra_scripts %}
{% if simulation_experiments %}
<script>
    // Store experiment data
    const experimentData = JSON.parse('{{ simulation_experiments|tojson|safe }}');
    
    let stopReasonChart, stopValueChart;
    let currentData = null;
    
    // More distinctive color palette with better visual separation
    const colors = [
        '#e11d48', // Bright red
        '#059669', // Emerald green
        '#2563eb', // Blue
        '#dc2626', // Red
        '#7c3aed', // Purple
        '#ea580c', // Orange
        '#0891b2', // Cyan
        '#be123c', // Rose
        '#16a34a', // Green
        '#9333ea', // Violet
        '#c2410c', // Orange red
        '#0284c7', // Sky blue
        '#be185d', // Pink
        '#65a30d', // Lime
        '#7c2d12', // Brown
        '#1e40af', // Blue (darker)
        '#991b1b', // Red (darker)
        '#581c87', // Purple (darker)
        '#0f766e', // Teal
        '#a21caf'  // Fuchsia
    ];
    
    function getSmoothingWindowSize() {
        const slider = document.getElementById('smoothing-slider');
        return parseInt(slider.value);
    }
    
    function updateSmoothingDisplay() {
        const windowSize = getSmoothingWindowSize();
        document.getElementById('smoothing-display').textContent = windowSize;
    }
    
    function applyRollingAverage(dataPoints, windowSize) {
        if (windowSize === 1) {
            return dataPoints; // No smoothing
        }
        
        const smoothedData = [];
        const halfWindow = Math.floor(windowSize / 2);
        
        for (let i = 0; i < dataPoints.length; i++) {
            const start = Math.max(0, i - halfWindow);
            const end = Math.min(dataPoints.length - 1, i + halfWindow);
            
            let sum = 0;
            let count = 0;
            
            for (let j = start; j <= end; j++) {
                sum += dataPoints[j].y;
                count++;
            }
            
            smoothedData.push({
                x: dataPoints[i].x,
                y: sum / count
            });
        }
        
        return smoothedData;
    }
    
    function resetDropdowns() {
        // Reset experiment dropdown to default
        const experimentSelect = document.getElementById('experiment-select');
        const simulationSelect = document.getElementById('simulation-select');
        
        experimentSelect.value = "";
        simulationSelect.innerHTML = '<option value="">-- Select experiment first --</option>';
        simulationSelect.disabled = true;
        
        // Hide charts and info
        document.getElementById('charts-container').style.display = 'none';
        document.getElementById('simulation-info').style.display = 'none';
        currentData = null;
    }
    
    function initializeCharts() {
        // Stop Reason Chart
        const ctx1 = document.getElementById('stopReasonChart').getContext('2d');
        stopReasonChart = new Chart(ctx1, {
            type: 'line',
            data: { datasets: [] },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Percentage of Simulations by Stop Reason',
                        font: { family: 'Monaco, monospace', size: 14 }
                    },
                    legend: {
                        display: true,
                        position: 'top',
                        labels: { font: { family: 'Monaco, monospace', size: 12 } }
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        titleFont: { family: 'Monaco, monospace' },
                        bodyFont: { family: 'Monaco, monospace' },
                        callbacks: {
                            label: function(context) {
                                return `${context.dataset.label}: ${context.parsed.y.toFixed(1)}%`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        type: 'linear',
                        title: {
                            display: true,
                            text: 'Start Token Index',
                            font: { family: 'Monaco, monospace' }
                        },
                        grid: { color: '#e2e8f0' },
                        ticks: {
                            font: { family: 'Monaco, monospace' },
                            stepSize: 25,
                            callback: function(value) {
                                return Math.round(value);
                            }
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Percentage (%)',
                            font: { family: 'Monaco, monospace' }
                        },
                        grid: { color: '#e2e8f0' },
                        min: 0,
                        max: 100,
                        ticks: {
                            font: { family: 'Monaco, monospace' }
                        }
                    }
                },
                interaction: {
                    intersect: false,
                    mode: 'index'
                }
            }
        });
        
        // Stop Value Chart
        const ctx2 = document.getElementById('stopValueChart').getContext('2d');
        stopValueChart = new Chart(ctx2, {
            type: 'line',
            data: { datasets: [] },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Stop Token Distribution (Percentage by Token)',
                        font: { family: 'Monaco, monospace', size: 14 }
                    },
                    legend: {
                        display: true,
                        position: 'bottom',
                        labels: { 
                            font: { family: 'Monaco, monospace', size: 10 },
                            boxWidth: 15,
                            padding: 10,
                            usePointStyle: true
                        }
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        titleFont: { family: 'Monaco, monospace', size: 12 },
                        bodyFont: { family: 'Monaco, monospace', size: 11 },
                        callbacks: {
                            title: function(context) {
                                return `Start Token Index: ${context[0].parsed.x}`;
                            },
                            label: function(context) {
                                return `${context.dataset.label}: ${context.parsed.y.toFixed(1)}%`;
                            },
                            footer: function(context) {
                                // Calculate total percentage shown
                                const total = context.reduce((sum, item) => sum + item.parsed.y, 0);
                                return `Total: ${total.toFixed(1)}%`;
                            }
                        },
                        footerFont: { family: 'Monaco, monospace', size: 10 },
                        footerColor: '#64748b'
                    }
                },
                scales: {
                    x: {
                        type: 'linear',
                        title: {
                            display: true,
                            text: 'Start Token Index',
                            font: { family: 'Monaco, monospace' }
                        },
                        grid: { color: '#e2e8f0' },
                        ticks: {
                            font: { family: 'Monaco, monospace' },
                            stepSize: 25,
                            callback: function(value) {
                                return Math.round(value);
                            }
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Percentage (%)',
                            font: { family: 'Monaco, monospace' }
                        },
                        grid: { color: '#e2e8f0' },
                        min: 0,
                        max: 100,
                        ticks: {
                            font: { family: 'Monaco, monospace' }
                        }
                    }
                },
                interaction: {
                    intersect: false,
                    mode: 'index'
                }
            }
        });
    }
    
    function updateSimulationOptions() {
        const experimentSelect = document.getElementById('experiment-select');
        const simulationSelect = document.getElementById('simulation-select');
        const selectedExperiment = experimentSelect.value;
        
        // Clear simulation options
        simulationSelect.innerHTML = '<option value="">-- Select a simulation --</option>';
        simulationSelect.disabled = !selectedExperiment;
        
        if (selectedExperiment) {
            const experiment = experimentData.find(exp => exp.name === selectedExperiment);
            if (experiment) {
                experiment.simulation_files.forEach(simFile => {
                    const option = document.createElement('option');
                    option.value = simFile.id;
                    option.textContent = `Simulation ${simFile.id}`;
                    simulationSelect.appendChild(option);
                });
            }
        }
        
        // Hide charts when experiment changes
        document.getElementById('charts-container').style.display = 'none';
        document.getElementById('simulation-info').style.display = 'none';
        currentData = null;
    }
    
    async function loadSimulationData() {
        const experimentSelect = document.getElementById('experiment-select');
        const simulationSelect = document.getElementById('simulation-select');
        const experiment = experimentSelect.value;
        const simulationId = simulationSelect.value;
        
        if (!experiment || !simulationId) {
            document.getElementById('charts-container').style.display = 'none';
            document.getElementById('simulation-info').style.display = 'none';
            currentData = null;
            return;
        }
        
        try {
            const response = await fetch(`/api/simulation-data?experiment=${experiment}&simulation_id=${simulationId}`);
            const data = await response.json();
            
            if (data.error) {
                alert(`Error: ${data.error}`);
                return;
            }
            
            console.log('Simulation data:', data); // Debug log
            
            // Store data for smoothing updates
            currentData = data;
            
            // Update statistics
            document.getElementById('total-simulations').textContent = data.total_simulations.toLocaleString();
            document.getElementById('simulation-info').style.display = 'block';
            
            // Update charts
            updateStopReasonChart(data);
            updateStopValueChart(data);
            
            // Show charts
            document.getElementById('charts-container').style.display = 'block';
            
        } catch (error) {
            console.error('Error loading simulation data:', error);
            alert('Failed to load simulation data');
        }
    }
    
    function updateStopReasonChart(data) {
        // Calculate x-axis range
        const minX = Math.min(...data.start_indices);
        const maxX = Math.max(...data.start_indices);
        
        const windowSize = getSmoothingWindowSize();
        
        console.log('Start indices range:', minX, 'to', maxX); // Debug log
        console.log('Smoothing window size:', windowSize); // Debug log
        
        // Prepare raw data
        const maxStepsData = data.start_indices.map(idx => ({
            x: idx,
            y: data.stop_reason_percentages[idx]?.max_steps_pct || 0
        }));
        
        const stopTokenData = data.start_indices.map(idx => ({
            x: idx,
            y: data.stop_reason_percentages[idx]?.stop_token_pct || 0
        }));
        
        // Apply smoothing
        const smoothedMaxStepsData = applyRollingAverage(maxStepsData, windowSize);
        const smoothedStopTokenData = applyRollingAverage(stopTokenData, windowSize);
        
        const datasets = [
            {
                label: 'Max Steps %',
                data: smoothedMaxStepsData,
                borderColor: '#64748b',
                backgroundColor: '#64748b' + '20',
                borderWidth: 2,
                fill: false,
                tension: 0.1,
                pointRadius: 1
            },
            {
                label: 'Stop Token %',
                data: smoothedStopTokenData,
                borderColor: '#059669',
                backgroundColor: '#059669' + '20',
                borderWidth: 2,
                fill: false,
                tension: 0.1,
                pointRadius: 1
            }
        ];
        
        // Update chart options with proper x-axis range
        stopReasonChart.options.scales.x.min = minX;
        stopReasonChart.options.scales.x.max = maxX;
        stopReasonChart.options.scales.x.ticks.stepSize = Math.max(1, Math.round((maxX - minX) / 10));
        
        stopReasonChart.data.datasets = datasets;
        stopReasonChart.update();
    }
    
    function updateStopValueChart(data) {
        if (!data.all_stop_values || data.all_stop_values.length === 0) {
            // No stop token data available
            stopValueChart.data.datasets = [];
            stopValueChart.update();
            return;
        }
        
        // Get indices that have stop value data
        const stopValueIndices = Object.keys(data.stop_value_percentages).map(k => parseInt(k));
        const minX = Math.min(...stopValueIndices);
        const maxX = Math.max(...stopValueIndices);
        
        const windowSize = getSmoothingWindowSize();
        
        console.log('Stop value indices range:', minX, 'to', maxX); // Debug log
        console.log('All stop values:', data.all_stop_values); // Debug log
        console.log('Stop value labels:', data.stop_value_labels); // Debug log
        
        const datasets = [];
        
        // Create a dataset for each unique stop value
        data.all_stop_values.forEach((stopValue, index) => {
            const color = colors[index % colors.length];
            const label = data.stop_value_labels[stopValue] || `Token ${stopValue}`;
            
            // Prepare raw data
            const rawData = stopValueIndices.map(idx => ({
                x: idx,
                y: data.stop_value_percentages[idx][stopValue] || 0
            }));
            
            // Apply smoothing
            const smoothedData = applyRollingAverage(rawData, windowSize);
            
            const dataset = {
                label: label,
                data: smoothedData,
                borderColor: color,
                backgroundColor: color + '20',
                borderWidth: 2,
                fill: false,
                tension: 0.1,
                pointRadius: 1
            };
            
            datasets.push(dataset);
        });
        
        // Update chart options with proper x-axis range
        stopValueChart.options.scales.x.min = minX;
        stopValueChart.options.scales.x.max = maxX;
        stopValueChart.options.scales.x.ticks.stepSize = Math.max(1, Math.round((maxX - minX) / 10));
        
        stopValueChart.data.datasets = datasets;
        stopValueChart.update();
    }
    
    function updateSmoothing() {
        updateSmoothingDisplay();
        if (currentData) {
            updateStopReasonChart(currentData);
            updateStopValueChart(currentData);
        }
    }
    
    // Initialize everything when page loads
    document.addEventListener('DOMContentLoaded', function() {
        initializeCharts();
        updateSmoothingDisplay();
        resetDropdowns(); // Reset dropdowns on page load
        
        // Add event listeners
        document.getElementById('experiment-select').addEventListener('change', updateSimulationOptions);
        document.getElementById('simulation-select').addEventListener('change', loadSimulationData);
        
        // Update smoothing display while dragging but only update charts on release
        document.getElementById('smoothing-slider').addEventListener('input', updateSmoothingDisplay);
        document.getElementById('smoothing-slider').addEventListener('change', updateSmoothing);
    });
</script>
{% endif %}
{% endblock %} 