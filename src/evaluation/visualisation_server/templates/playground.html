{% extends "base.html" %}

{% block title %}Model Playground - Nightingale{% endblock %}

{% block extra_head %}
<style>
/* Playground-specific styles using the existing design system */
.playground-section {
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-radius: var(--border-radius);
    padding: var(--space-lg);
    margin-bottom: var(--space-lg);
}

.input-methods {
    display: flex;
    gap: var(--space-sm);
    margin-bottom: var(--space-md);
}

.input-method-btn {
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    padding: var(--space-xs) var(--space-sm);
    border-radius: var(--border-radius);
    cursor: pointer;
    font-family: var(--font-mono);
    font-size: var(--font-size-sm);
    transition: all 0.2s ease;
    color: var(--color-text-primary);
}

.input-method-btn.active {
    background: var(--color-primary);
    color: white;
    border-color: var(--color-primary);
}

.input-method-btn:hover {
    border-color: var(--color-primary);
}

.input-method-section {
    display: none;
}

.input-method-section.active {
    display: block;
}

.form-group {
    margin-bottom: var(--space-md);
}

.form-group label {
    display: block;
    margin-bottom: var(--space-xs);
    font-weight: 600;
    color: var(--color-text-primary);
    font-size: var(--font-size-sm);
}

.form-control {
    width: 100%;
    padding: var(--space-sm);
    border: 1px solid var(--color-border);
    border-radius: var(--border-radius);
    font-family: var(--font-mono);
    font-size: var(--font-size-sm);
    background: var(--color-surface);
    color: var(--color-text-primary);
}

.form-control:focus {
    outline: none;
    border-color: var(--color-primary);
}

.token-sequence {
    display: flex;
    gap: var(--space-xs);
    flex-wrap: wrap;
    padding: var(--space-sm);
    background: var(--color-subtle);
    border-radius: var(--border-radius);
    min-height: 40px;
    align-items: center;
}

.token-badge {
    background: var(--color-accent-subtle);
    color: var(--color-primary);
    padding: var(--space-xs) var(--space-sm);
    border-radius: var(--border-radius);
    font-size: 12px;
    font-weight: 600;
    display: inline-flex;
    align-items: center;
    gap: var(--space-xs);
    font-family: var(--font-mono);
}

.token-badge .remove {
    cursor: pointer;
    color: var(--color-text-secondary);
    font-weight: bold;
    margin-left: var(--space-xs);
}

.token-badge .remove:hover {
    color: #dc3545;
}

.search-results {
    max-height: 200px;
    overflow-y: auto;
    border: 1px solid var(--color-border);
    border-radius: var(--border-radius);
    background: var(--color-surface);
    margin-top: var(--space-xs);
}

.search-result-item {
    padding: var(--space-sm);
    cursor: pointer;
    border-bottom: 1px solid var(--color-border);
    font-family: var(--font-mono);
    font-size: var(--font-size-sm);
}

.search-result-item:hover {
    background: var(--color-subtle);
}

.search-result-item:last-child {
    border-bottom: none;
}

.predictions-table {
    width: 100%;
    border-collapse: collapse;
    margin-top: var(--space-md);
    font-family: var(--font-mono);
    font-size: var(--font-size-sm);
}

.predictions-table th,
.predictions-table td {
    text-align: left;
    padding: var(--space-sm);
    border-bottom: 1px solid var(--color-border);
}

.predictions-table th {
    background: var(--color-subtle);
    font-weight: 600;
    color: var(--color-text-primary);
}

.predictions-table tr:hover {
    background: var(--color-subtle);
}

.token-display {
    font-family: var(--font-mono);
    background: var(--color-subtle);
    padding: 2px var(--space-xs);
    border-radius: var(--border-radius);
    font-size: 12px;
}

.probability-bar {
    background: var(--color-border);
    height: 20px;
    border-radius: 10px;
    overflow: hidden;
    position: relative;
    min-width: 100px;
}

.probability-fill {
    background: linear-gradient(90deg, var(--color-primary), var(--color-accent));
    height: 100%;
    transition: width 0.3s ease;
}

.probability-text {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 10px;
    font-weight: 600;
    color: var(--color-text-primary);
}

.experiment-info {
    background: var(--color-subtle);
    padding: var(--space-sm);
    border-radius: var(--border-radius);
    margin-top: var(--space-sm);
    font-size: var(--font-size-sm);
    color: var(--color-text-secondary);
}

.loading {
    text-align: center;
    padding: var(--space-xl);
    color: var(--color-text-secondary);
    font-style: italic;
}

.error-message {
    background: #fef2f2;
    color: #dc2626;
    padding: var(--space-sm);
    border-radius: var(--border-radius);
    border: 1px solid #fecaca;
    margin-top: var(--space-sm);
}

.btn-small {
    padding: 4px var(--space-xs);
    font-size: 11px;
    line-height: 1.2;
}

.control-row {
    display: flex;
    gap: var(--space-md);
    align-items: center;
    flex-wrap: wrap;
}

.control-row .form-group {
    margin-bottom: 0;
}

.btn-group {
    display: flex;
    gap: var(--space-sm);
}
</style>
{% endblock %}

{% block content %}
<div class="container">
    <section class="hero">
        <h1>Model Playground</h1>
        <p class="hero-subtitle">
            Test token sequences with trained models and see predicted next tokens
        </p>
    </section>

    <div class="playground-section">
        <h3>Select Experiment</h3>
        <div class="form-group">
            <label for="experiment-select">Choose an experiment with a trained model:</label>
            <select id="experiment-select" class="control-select">
                <option value="">Choose an experiment...</option>
                {% for experiment in experiments %}
                <option value="{{ experiment.name }}" 
                        data-model-type="{{ experiment.model_type }}"
                        data-vocab-size="{{ experiment.vocab_size }}"
                        data-sequence-length="{{ experiment.sequence_length }}">
                    {{ experiment.name }} ({{ experiment.model_type|upper }})
                </option>
                {% endfor %}
            </select>
            <div id="experiment-info" class="experiment-info" style="display: none;"></div>
        </div>
    </div>

    <div class="playground-section">
        <h3>Input Tokens</h3>
        
        <div class="input-methods">
            <div class="input-method-btn active" data-method="token-ids">Token IDs</div>
            <div class="input-method-btn" data-method="search-tokens">Search Tokens</div>
        </div>

        <div id="token-ids-section" class="input-method-section active">
            <div class="form-group">
                <label for="token-ids-input">Enter Token IDs (comma-separated):</label>
                <input type="text" id="token-ids-input" class="form-control" 
                       placeholder="e.g., 0,15,234,67">
            </div>
        </div>

        <div id="search-tokens-section" class="input-method-section">
            <div class="form-group">
                <label for="token-search">Search and Add Tokens:</label>
                <input type="text" id="token-search" class="form-control" 
                       placeholder="Search for tokens by their string representation">
                <div id="search-results" class="search-results" style="display: none;"></div>
            </div>
        </div>

        <div class="form-group">
            <label>Current Token Sequence:</label>
            <div id="current-tokens" class="token-sequence">
                <span class="text-secondary">No tokens added</span>
            </div>
        </div>

        <div class="control-row">
            <div class="form-group">
                <label for="top-k">Predictions to show:</label>
                <select id="top-k" class="control-select" style="width: auto;">
                    <option value="5">5</option>
                    <option value="10" selected>10</option>
                    <option value="15">15</option>
                    <option value="20">20</option>
                </select>
            </div>
            <div class="btn-group">
                <button id="predict-btn" class="btn btn-primary" disabled>Predict Next Tokens</button>
                <button id="clear-tokens-btn" class="btn">Clear Tokens</button>
            </div>
        </div>
    </div>

    <div class="playground-section">
        <h3>Predictions</h3>
        <div id="predictions-content">
            <p class="text-secondary">Select an experiment and input some tokens to see predictions. Click "Add" buttons to append tokens to your sequence and generate new predictions.</p>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_scripts %}
<script>
let currentExperiment = null;
let currentVocab = {};
let currentTokens = [];

// HTML escape function to handle tokens with < > characters
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// DOM elements
const experimentSelect = document.getElementById('experiment-select');
const experimentInfo = document.getElementById('experiment-info');
const tokenIdsInput = document.getElementById('token-ids-input');
const tokenSearch = document.getElementById('token-search');
const searchResults = document.getElementById('search-results');
const currentTokensDiv = document.getElementById('current-tokens');
const predictBtn = document.getElementById('predict-btn');
const clearTokensBtn = document.getElementById('clear-tokens-btn');
const topKSelect = document.getElementById('top-k');
const predictionsContent = document.getElementById('predictions-content');

// Input method switching
document.querySelectorAll('.input-method-btn').forEach(btn => {
    btn.addEventListener('click', () => {
        document.querySelectorAll('.input-method-btn').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.input-method-section').forEach(s => s.classList.remove('active'));
        
        btn.classList.add('active');
        document.getElementById(`${btn.dataset.method}-section`).classList.add('active');
    });
});

// Experiment selection
experimentSelect.addEventListener('change', async () => {
    const selectedOption = experimentSelect.selectedOptions[0];
    if (!selectedOption.value) {
        currentExperiment = null;
        currentVocab = {};
        experimentInfo.style.display = 'none';
        updatePredictButton();
        return;
    }

    currentExperiment = selectedOption.value;
    
    // Show experiment info
    experimentInfo.innerHTML = `
        <strong>Model Type:</strong> ${selectedOption.dataset.modelType}<br>
        <strong>Vocabulary Size:</strong> ${selectedOption.dataset.vocabSize}<br>
        <strong>Sequence Length:</strong> ${selectedOption.dataset.sequenceLength}
    `;
    experimentInfo.style.display = 'block';

    // Load vocabulary
    try {
        const response = await fetch(`/api/experiment-vocab?experiment=${currentExperiment}`);
        const data = await response.json();
        if (data.error) {
            throw new Error(data.error);
        }
        currentVocab = data.vocab;
    } catch (error) {
        console.error('Failed to load vocabulary:', error);
        currentVocab = {};
    }

    updatePredictButton();
});

// Token IDs input
tokenIdsInput.addEventListener('input', () => {
    const input = tokenIdsInput.value.trim();
    if (input) {
        try {
            const tokens = input.split(',').map(t => parseInt(t.trim())).filter(t => !isNaN(t));
            currentTokens = tokens;
        } catch (error) {
            currentTokens = [];
        }
    } else {
        currentTokens = [];
    }
    updateCurrentTokensDisplay();
    updatePredictButton();
});

// Token search
let searchTimeout;
tokenSearch.addEventListener('input', () => {
    clearTimeout(searchTimeout);
    searchTimeout = setTimeout(() => {
        searchTokens(tokenSearch.value.trim());
    }, 300);
});

function searchTokens(query) {
    if (!query || !currentVocab) {
        searchResults.style.display = 'none';
        return;
    }

    const matches = [];
    for (const [tokenId, tokenStr] of Object.entries(currentVocab)) {
        if (tokenStr.toLowerCase().includes(query.toLowerCase())) {
            matches.push({ id: parseInt(tokenId), str: tokenStr });
        }
        if (matches.length >= 20) break; // Limit results
    }

    if (matches.length > 0) {
        searchResults.innerHTML = matches.map(match => 
            `<div class="search-result-item" onclick="addToken(${match.id})">
                <span class="token-display">${escapeHtml(match.str)}</span> (ID: ${match.id})
            </div>`
        ).join('');
        searchResults.style.display = 'block';
    } else {
        searchResults.style.display = 'none';
    }
}

function addToken(tokenId) {
    if (!currentTokens.includes(tokenId)) {
        currentTokens.push(tokenId);
        updateCurrentTokensDisplay();
        updatePredictButton();
        tokenIdsInput.value = currentTokens.join(',');
    }
    tokenSearch.value = '';
    searchResults.style.display = 'none';
}

function appendTokenAndPredict(tokenId, event) {
    // Prevent default behavior and stop event propagation to avoid scrolling
    if (event) {
        event.preventDefault();
        event.stopPropagation();
        event.stopImmediatePropagation();
    }
    
    // Add the token to the sequence
    currentTokens.push(tokenId);
    
    // Update displays
    updateCurrentTokensDisplay();
    updatePredictButton();
    
    // Clear the token ID input to reflect the current state
    tokenIdsInput.value = currentTokens.join(',');
    
    // Automatically trigger a new prediction
    if (currentExperiment && currentTokens.length > 0) {
        predictBtn.click();
    }
    
    // Explicitly return false to prevent any default behavior
    return false;
}

function removeToken(index) {
    currentTokens.splice(index, 1);
    updateCurrentTokensDisplay();
    updatePredictButton();
    tokenIdsInput.value = currentTokens.join(',');
}

function updateCurrentTokensDisplay() {
    if (currentTokens.length === 0) {
        currentTokensDiv.innerHTML = '<span class="text-secondary">No tokens added</span>';
        return;
    }

    currentTokensDiv.innerHTML = currentTokens.map((tokenId, index) => {
        const tokenStr = currentVocab[tokenId] || `<UNK:${tokenId}>`;
        return `<span class="token-badge">
            <span class="token-display">${escapeHtml(tokenStr)}</span> (${tokenId})
            <span class="remove" onclick="removeToken(${index})">×</span>
        </span>`;
    }).join('');
}

function updatePredictButton() {
    predictBtn.disabled = !currentExperiment || currentTokens.length === 0;
}

// Clear tokens
clearTokensBtn.addEventListener('click', () => {
    currentTokens = [];
    tokenIdsInput.value = '';
    updateCurrentTokensDisplay();
    updatePredictButton();
    // Clear any existing predictions
    predictionsContent.innerHTML = '<p class="text-secondary">Select an experiment and input some tokens to see predictions. Click "Add" buttons to append tokens to your sequence and generate new predictions.</p>';
});

// Predict
predictBtn.addEventListener('click', async () => {
    if (!currentExperiment || currentTokens.length === 0) return;

    predictBtn.disabled = true;
    predictionsContent.innerHTML = '<div class="loading">Making prediction...</div>';

    try {
        const response = await fetch('/api/inference', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                experiment_name: currentExperiment,
                input_tokens: currentTokens,
                top_k: parseInt(topKSelect.value)
            })
        });

        const data = await response.json();
        
        if (data.error) {
            throw new Error(data.error);
        }

        displayPredictions(data);
    } catch (error) {
        predictionsContent.innerHTML = `<div class="error-message">Error: ${error.message}</div>`;
    } finally {
        predictBtn.disabled = false;
        updatePredictButton();
    }
});

function displayPredictions(data) {
    const maxProb = Math.max(...data.predictions.map(p => p.probability));
    
    const table = `
        <table class="predictions-table">
            <thead>
                <tr>
                    <th>Rank</th>
                    <th>Token</th>
                    <th>ID</th>
                    <th>Probability</th>
                    <th>Logit</th>
                    <th>Action</th>
                </tr>
            </thead>
            <tbody>
                ${data.predictions.map((pred, index) => `
                    <tr>
                        <td>${index + 1}</td>
                        <td><span class="token-display">${escapeHtml(pred.token_str)}</span></td>
                        <td>${pred.token_id}</td>
                        <td>
                            <div class="probability-bar">
                                <div class="probability-fill" style="width: ${(pred.probability / maxProb) * 100}%"></div>
                                <div class="probability-text">${(pred.probability * 100).toFixed(2)}%</div>
                            </div>
                        </td>
                        <td>${pred.logit.toFixed(4)}</td>
                        <td><button type="button" class="btn btn-small" onclick="return appendTokenAndPredict(${pred.token_id}, event)" title="Add this token to sequence">Add</button></td>
                    </tr>
                `).join('')}
            </tbody>
        </table>
    `;

    predictionsContent.innerHTML = `
        <p><strong>Input sequence length:</strong> ${data.input_length} tokens</p>
        ${table}
    `;
}

// Initialize
updatePredictButton();
</script>
{% endblock %} 